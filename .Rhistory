nrow(filter(births, father_age == 99))
sum(is.na(births$gestation_weeks))
sum(is.na(births$father_age))
tmpBirths <- births %>% filter(!is.na(father_age)) %>% sample_n(5000)
ggplot(tmpBirths, aes(x = father_age, y = gestation_weeks)) + geom_point(shape = 1, alpha = 0.1, color = "blue") + geom_smooth(method=lm)
fatherRace <- births %>% group_by(father_race) %>% summarise(meanGestation = mean(gestation_weeks))
ggplot(fatherRace, aes(as.factor(father_race), meanGestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="`father_race`", y = "Average Gestation")
if(!require(easypackages)){install.packages("easypackages")}
library(easypackages)
packages("plyr", "dplyr", "xda", "ggplot2", "readr", "gridExtra", "funModeling",
"corrplot", prompt = FALSE)
library(readr)
births <- read.csv("C:\\Users\\czwea\\Documents\\GitHub\\LargeDataFiles\\births.csv")
births <-select(births, -1)
df_status(births)
#births$mother_race <- as.factor(births$mother_race)
births$mother_race <- mapvalues(births$mother_race, from = c(1, 2, 3, 4, 5, 6, 7), to = c("White", "Black", "American_Indian", "Chinese", "Japanese", "Hawaiian", "Filipino"))
births <- mutate(births, mother_race = case_when(mother_race == "68" ~ "Other_Asian",
mother_race =="18" ~ "Other_Asian",
mother_race =="78" ~ "Other_Asian",
mother_race =="48" ~ "Other_Asian",
mother_race =="28" ~ "Other_Asian",
mother_race =="38" ~ "Other_Asian",
mother_race =="58" ~ "Other_Asian",
TRUE ~ as.character(mother_race)))
births$father_race <- mapvalues(births$father_race, from = c(1, 2, 3, 4, 5, 6, 7), to = c("White", "Black", "American_Indian", "Chinese", "Japanese", "Hawaiian", "Filipino"))
births <- mutate(births, father_race = case_when(father_race == "68" ~ "Other_Asian",
father_race =="18" ~ "Other_Asian",
father_race =="78" ~ "Other_Asian",
father_race =="48" ~ "Other_Asian",
father_race =="28" ~ "Other_Asian",
father_race =="38" ~ "Other_Asian",
father_race =="58" ~ "Other_Asian",
TRUE ~ as.character(father_race)))
unique(births$father_race)
unique(births$mother_race)
if(!require(easypackages)){install.packages("easypackages")}
library(easypackages)
packages("plyr", "dplyr", "xda", "ggplot2", "readr", "gridExtra", "funModeling",
"corrplot", prompt = FALSE)
library(readr)
births <- read.csv("C:\\Users\\czwea\\Documents\\GitHub\\LargeDataFiles\\births.csv")
births <-select(births, -1)
df_status(births)
births$mother_race <- mapvalues(births$mother_race, from = c(1, 2, 3, 4, 5, 6, 7), to = c("White", "Black", "American_Indian", "Chinese", "Japanese", "Hawaiian", "Filipino"))
births <- mutate(births, mother_race = case_when(mother_race == "68" ~ "Other_Asian",
mother_race =="18" ~ "Other_Asian",
mother_race =="78" ~ "Other_Asian",
mother_race =="48" ~ "Other_Asian",
mother_race =="28" ~ "Other_Asian",
mother_race =="38" ~ "Other_Asian",
mother_race =="58" ~ "Other_Asian",
TRUE ~ as.character(mother_race)))
births <- births %>% filter(!father_race == "99")
births$father_race <- mapvalues(births$father_race, from = c(1, 2, 3, 4, 5, 6, 7), to = c("White", "Black", "American_Indian", "Chinese", "Japanese", "Hawaiian", "Filipino"))
births <- mutate(births, father_race = case_when(father_race == "68" ~ "Other_Asian",
father_race =="18" ~ "Other_Asian",
father_race =="78" ~ "Other_Asian",
father_race =="48" ~ "Other_Asian",
father_race =="28" ~ "Other_Asian",
father_race =="38" ~ "Other_Asian",
father_race =="58" ~ "Other_Asian",
TRUE ~ as.character(father_race)))
freq(births, input = c("mother_race", "cigarette_use", "alcohol_use", "is_male"))
freq(births, input = c("plurality"))
plot_num(births)
range(births$father_age)
#table(births$father_age)
nrow(filter(births, father_age ==99))
births$father_age <- na_if(births$father_age, 99)
nrow(filter(births, father_age == 99))
sum(is.na(births$gestation_weeks))
sum(is.na(births$father_age))
tmpBirths <- births %>% filter(!is.na(father_age)) %>% sample_n(5000)
ggplot(tmpBirths, aes(x = father_age, y = gestation_weeks)) + geom_point(shape = 1, alpha = 0.1, color = "blue") + geom_smooth(method=lm)
sum(is.na(tmpBirths$father_race))
tmpBirths <- tmpBirths %>% filter(!is.na(father_race))
ggplot(tmpBirths, aes(x = father_age, y = gestation_weeks)) + geom_point(shape = 1, alpha = 0.1, color = "blue") + geom_smooth(method=lm) + facet_wrap(~father_race)
fatherRace <- births %>% group_by(father_race) %>% summarise(meanGestation = mean(gestation_weeks))
ggplot(fatherRace, aes(as.factor(father_race), meanGestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="`father_race`", y = "Average Gestation")
ggplot(fatherRace, aes(as.factor(father_race), meanGestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="`father_race`", y = "Average Gestation") +
coord_cartesian(ylim = c(38, 39.2)) +
geom_hline(yintercept = 38.69, linetype = "dashed", color = "red")
motherRace <- births %>% group_by(mother_race) %>% summarise(meanGestation = mean(gestation_weeks))
ggplot(motherRace, aes(as.factor(mother_race), meanGestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="`mother_race`", y = "Average Gestation") +
coord_cartesian(ylim = c(38, 39.2)) +
geom_hline(yintercept = 38.69, linetype = "dashed", color = "red")
if(!require(easypackages)){install.packages("easypackages")}
library(easypackages)
packages("plyr", "dplyr", "xda", "ggplot2", "readr", "gridExtra", "funModeling",
"corrplot", prompt = FALSE)
library(readr)
births <- read.csv("C:\\Users\\czwea\\Documents\\GitHub\\LargeDataFiles\\births.csv")
births <-select(births, -1)
df_status(births)
births$mother_race <- mapvalues(births$mother_race, from = c(1, 2, 3, 4, 5, 6, 7), to = c("White", "Black", "American_Indian", "Chinese", "Japanese", "Hawaiian", "Filipino"))
births <- mutate(births, mother_race = case_when(mother_race == "68" ~ "Other_Asian",
mother_race =="18" ~ "Other_Asian",
mother_race =="78" ~ "Other_Asian",
mother_race =="48" ~ "Other_Asian",
mother_race =="28" ~ "Other_Asian",
mother_race =="38" ~ "Other_Asian",
mother_race =="58" ~ "Other_Asian",
TRUE ~ as.character(mother_race)))
births <- births %>% filter(!father_race == "99")
births$father_race <- mapvalues(births$father_race, from = c(1, 2, 3, 4, 5, 6, 7), to = c("White", "Black", "American_Indian", "Chinese", "Japanese", "Hawaiian", "Filipino"))
births <- mutate(births, father_race = case_when(father_race == "68" ~ "Other_Asian",
father_race =="18" ~ "Other_Asian",
father_race =="78" ~ "Other_Asian",
father_race =="48" ~ "Other_Asian",
father_race =="28" ~ "Other_Asian",
father_race =="38" ~ "Other_Asian",
father_race =="58" ~ "Other_Asian",
TRUE ~ as.character(father_race)))
freq(births, input = c("mother_race", "cigarette_use", "alcohol_use", "is_male"))
freq(births, input = c("plurality"))
plot_num(births)
range(births$father_age)
#table(births$father_age)
nrow(filter(births, father_age ==99))
births$father_age <- na_if(births$father_age, 99)
nrow(filter(births, father_age == 99))
sum(is.na(births$gestation_weeks))
sum(is.na(births$father_age))
tmpBirths <- births %>% filter(!is.na(father_age)) %>% sample_n(5000)
ggplot(tmpBirths, aes(x = father_age, y = gestation_weeks)) + geom_point(shape = 1, alpha = 0.1, color = "blue") + geom_smooth(method=lm)
sum(is.na(tmpBirths$father_race))
tmpBirths <- tmpBirths %>% filter(!is.na(father_race))
ggplot(tmpBirths, aes(x = father_age, y = gestation_weeks)) + geom_point(shape = 1, alpha = 0.1, color = "blue") + geom_smooth(method=lm) + facet_wrap(~father_race)
sum(is.na(tmpBirths$mother_age))
ggplot(tmpBirths, aes(x = mother_age, y = gestation_weeks)) + geom_point(shape = 1, alpha = 0.1, color = "blue") + geom_smooth(method=lm) + facet_wrap(~mother_race)
fatherRace <- births %>% group_by(father_race) %>% summarise(meanGestation = mean(gestation_weeks))
ggplot(fatherRace, aes(as.factor(father_race), meanGestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="`father_race`", y = "Average Gestation")
ggplot(fatherRace, aes(as.factor(father_race), meanGestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="`father_race`", y = "Average Gestation") +
coord_cartesian(ylim = c(38, 39.2)) +
geom_hline(yintercept = 38.69, linetype = "dashed", color = "red")
motherRace <- births %>% group_by(mother_race) %>% summarise(meanGestation = mean(gestation_weeks))
ggplot(motherRace, aes(as.factor(mother_race), meanGestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="`mother_race`", y = "Average Gestation") +
coord_cartesian(ylim = c(38, 39.2)) +
geom_hline(yintercept = 38.69, linetype = "dashed", color = "red")
gestation <- births %>% group_by(as.factor(plurality)) %>%
summarise(meanGestation = mean(gestation_weeks))
names(gestation) <-  c("Plurality", "Average_Gestation")
ggplot(gestation, aes(Plurality, Average_Gestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="Number of Babies Birthed", y = "Average Gestation") +
geom_hline(yintercept = mean(gestation$Average_Gestation), linetype = "dashed", color = "red")
ggplot(births, aes(as.factor(plurality), gestation_weeks)) +
geom_boxplot(color = "navy", fill = "navy", alpha = .3, na.rm = TRUE) +
labs(x="Number of Babies Birthed", y = "Average Gestation")
model_lm1 = lm(gestation_weeks ~ father_age, data = births)
summary(model_lm1)
ggplot(tmpBirths, aes(x = father_age, y = gestation_weeks)) +
geom_point(shape = 1, alpha = 0.1, color = "blue") + geom_smooth(method=lm, se= FALSE) +
geom_hline(yintercept = 38.69, linetype = "dashed", color = "red") +
coord_cartesian(ylim = c(35, 42.5))
model_lm2 = lm(gestation_weeks ~ mother_age, data = births)
summary(model_lm2)
tmpBirths <- births %>% filter(!is.na(father_age), mother_age) %>% sample_n(5000)
ggplot(tmpBirths, aes(x = father_age, y = mother_age)) +
geom_point(shape = 1, alpha = 0.1, color = "blue") + geom_smooth(method=lm)
fatherRace <- births %>% group_by(father_race) %>% summarise(meanGestation = mean(gestation_weeks))
ggplot(fatherRace, aes(as.factor(father_race), meanGestation)) +
geom_bar(stat="identity", color = "navy", fill = "navy", alpha = .3) +
labs(x="`father_race`", y = "Average Gestation") +
geom_hline(yintercept = 38.69, linetype = "dashed", color = "red")
set.seed(12345)
#Pearson
cor(tmpBirths$mother_age, tmpBirths$father_age, use = "complete.obs")
cor.test(tmpBirths$mother_age, tmpBirths$father_age)#gets the p value
tmpBirths_1 <- tmpBirths %>% select(mother_age, father_age) %>% drop_na()
set.seed(12345)
#Pearson
cor(tmpBirths$mother_age, tmpBirths$father_age, use = "complete.obs")
cor.test(tmpBirths$mother_age, tmpBirths$father_age)#gets the p value
tmpBirths_1 <- tmpBirths %>% select(mother_age, father_age) %>% tidyr::drop_na()
correlation_table(tmpBirths_1, "mother_age")
#Pairwise Coefficients
correlation_table(tmpBirths[!is.na(tmpBirths$father_age),], "mother_age")
cor(select_if(tmpBirths, is.numeric), use = "complete.obs")
myCOR <- cor(select_if(tmpBirths, is.numeric), use = "complete.obs")
corrplot.mixed(myCOR, number.cex = .8, tl.pos = "lt")
library("PerformanceAnalytics")
chart.Correlation(select_if(tmpBirths, is.numeric), histogram = TRUE, pch = 19)
set.seed(12345)
#Pearson
cor(tmpBirths$mother_age, tmpBirths$father_age, use = "complete.obs")
cor.test(tmpBirths$mother_age, tmpBirths$father_age)#gets the p value
tmpBirths_1 <- tmpBirths %>% select(mother_age, father_age) %>% tidyr::drop_na()
correlation_table(tmpBirths_1, "mother_age")
cor(select_if(tmpBirths, is.numeric), use = "complete.obs")
myCOR <- cor(select_if(tmpBirths, is.numeric), use = "complete.obs")
corrplot.mixed(myCOR, number.cex = .8, tl.pos = "lt")
myCOR <- cor(select_if(tmpBirths, is.numeric), use = "complete.obs")
corrplot.mixed(myCOR, number.cex = .8, tl.pos = "lt")
library("PerformanceAnalytics")
chart.Correlation(select_if(tmpBirths, is.numeric), histogram = TRUE, pch = 19)
set.seed(1)
model_lm3 <- lm(gestation_weeks ~ mother_age + father_age, data = tmpBirths)
summary(model_lm3)
model_lm4 <- lm(gestation_weeks ~ factor(mother_race), data = births)
summary(model_lm4)
forcats::fct_relevel(mother_race, "White")
forcats::fct_relevel(births, mother_race, "White")
forcats::fct_relevel(births$mother_race, "White")
births$mother_race <- forcats::fct_relevel(births$mother_race, "White")
model_lm4_2 <- lm(gestation_weeks ~ factor(mother_race), data = births)
summary(model_lm4_2)
ggplot(tmpBirths, aes(x = mother_race, fill = father_race)) + geom_bar(position = "fill")
model_lm5 <- lm(gestation_weeks ~ mother_race + father_race, data = births)
summary(model_lm5)
if(!require(easypackages)){install.packages("easypackages")}
library(easypackages)
packages("plyr", "dplyr", "xda", "ggplot2", "readr", "gridExtra", "caret", prompt = FALSE)
library(DMwR) # for smote implementation
library(purrr) # for functional programming (map)
library(pROC) # for AUC calculations
set.seed(2969)
imbal_train <- twoClassSim(5000, intercept = -25, linearVars = 20, noiseVars = 10)
imbal_test  <- twoClassSim(5000, intercept = -25, linearVars = 20, noiseVars = 10)
prop.table(table(imbal_train$Class))
set.seed(5627)
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 5, summaryFunction = twoClassSummary, classProbs = TRUE)
# Build a standard classifier using a gradient boosted machine
orig_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build custom AUC function to extract AUC from the caret model object
test_roc <- function(model, data) {
roc(data$Class, predict(model, data, type = "prob")[, "Class2"])}
orig_fit %>% test_roc(data = imbal_test) %>% auc()
# Create model weights (they sum to one)
model_weights <- ifelse(imbal_train$Class == "Class1",
(1/table(imbal_train$Class)[1]) * 0.5,
(1/table(imbal_train$Class)[2]) * 0.5)
# Use the same seed to ensure same cross-validation splits
ctrl$seeds <- orig_fit$control$seeds
# Build weighted model
weighted_fit <- train(Class ~ ., dta = imbal_train, method = "gbm", verbose = FALSE, weights = model_weights,
metric = "ROC", trControl = ctrl)
# Create model weights (they sum to one)
model_weights <- ifelse(imbal_train$Class == "Class1",
(1/table(imbal_train$Class)[1]) * 0.5,
(1/table(imbal_train$Class)[2]) * 0.5)
# Use the same seed to ensure same cross-validation splits
ctrl$seeds <- orig_fit$control$seeds
# Build weighted model
weighted_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, weights = model_weights,
metric = "ROC", trControl = ctrl)
# Build down-sampled model
ctrl$sampling <- "down"
down_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build up-sampled model
ctrl$sampling <- "up"
up_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build smote model
ctrl$sampling <- "smote"
smote_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
model_list <- list(original = orig_fit, weighted = weighted_fit, down = down_fit, up = up_fit, SMOTE = smote_fit)
model_list_roc <- model_list %>% map(test_roc, data = imbal_test)
model_list_roc %>% map(auc)
results_list_roc <- list(NA)
num_mod <- 1
for(the_roc in model_list_roc){
results_list_roc[[num_mod]] <-
data_frame(tpr = the_roc$sensitivities,
fpr = 1 - the_roc$specificities,
model = names(model_list)[num_mod])
num_mod <- num_mod + 1
}
results_df_roc <- bind_rows(results_list_roc)
# Plot ROC curve for all 5 models
custom_col <- c("#000000", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
ggplot(aes(x = fpr,  y = tpr, group = model), data = results_df_roc) + geom_line(aes(color = model), size = 1) +
scale_color_manual(values = custom_col) + geom_abline(intercept = 0, slope = 1, color = "gray", size = 1) +
theme_bw(base_size = 18)
getwd()
orig_fit$bestTune
orig_pr$bestTune
orig_fit_test
if(!require(easypackages)){install.packages("easypackages")}
library(easypackages)
packages("plyr", "dplyr", "xda", "ggplot2", "readr", "gridExtra", "caret", "PRROC", prompt = FALSE)
library(DMwR) # for smote implementation
library(purrr) # for functional programming (map)
library(pROC) # for AUC calculations
set.seed(2969)
imbal_train <- twoClassSim(5000, intercept = -25, linearVars = 20, noiseVars = 10)
imbal_test  <- twoClassSim(5000, intercept = -25, linearVars = 20, noiseVars = 10)
prop.table(table(imbal_train$Class))
set.seed(5627)
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 5, summaryFunction = twoClassSummary, classProbs = TRUE)
# Build a standard classifier using a gradient boosted machine
orig_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build custom AUC function to extract AUC from the caret model object
test_roc <- function(model, data) {
roc(data$Class, predict(model, data, type = "prob")[, "Class2"])}
orig_fit %>% test_roc(data = imbal_test) %>% auc()
# Create model weights (they sum to one)
model_weights <- ifelse(imbal_train$Class == "Class1",
(1/table(imbal_train$Class)[1]) * 0.5,
(1/table(imbal_train$Class)[2]) * 0.5)
# Use the same seed to ensure same cross-validation splits
ctrl$seeds <- orig_fit$control$seeds
# Build weighted model
weighted_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, weights = model_weights,
metric = "ROC", trControl = ctrl)
# Build down-sampled model
ctrl$sampling <- "down"
down_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build up-sampled model
ctrl$sampling <- "up"
up_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build smote model
ctrl$sampling <- "smote"
smote_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
model_list <- list(original = orig_fit, weighted = weighted_fit, down = down_fit, up = up_fit, SMOTE = smote_fit)
model_list_roc <- model_list %>% map(test_roc, data = imbal_test)
model_list_roc %>% map(auc)
results_list_roc <- list(NA)
num_mod <- 1
for(the_roc in model_list_roc){
results_list_roc[[num_mod]] <-
data_frame(tpr = the_roc$sensitivities,
fpr = 1 - the_roc$specificities,
model = names(model_list)[num_mod])
num_mod <- num_mod + 1
}
results_df_roc <- bind_rows(results_list_roc)
# Plot ROC curve for all 5 models
custom_col <- c("#000000", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
ggplot(aes(x = fpr,  y = tpr, group = model), data = results_df_roc) + geom_line(aes(color = model), size = 1) +
scale_color_manual(values = custom_col) + geom_abline(intercept = 0, slope = 1, color = "gray", size = 1) +
theme_bw(base_size = 18)
calc_auprc <- function(model, data){
index_class2 <- data$Class == "Class2"
index_class1 <- data$Class == "Class1"
predictions <- predict(model, data, type = "prob")
pr.curve(predictions$Class2[index_class2], predictions$Class2[index_class1], curve = TRUE)##pr.curve is in PRROC
}
# Get results for all 5 models
model_list_pr <- model_list %>% map(calc_auprc, data = imbal_test)
model_list_pr %>% map(function(the_mod) the_mod$auc.integral)
# Plot the AUPRC curve for all 5 models
results_list_pr <- list(NA)
num_mod <- 1
for(the_pr in model_list_pr){
results_list_pr[[num_mod]] <- data_frame(recall = the_pr$curve[, 1],
precision = the_pr$curve[, 2],
model = names(model_list_pr)[num_mod])
num_mod <- num_mod + 1
}
results_df_pr <- bind_rows(results_list_pr)
custom_col <- c("#000000", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
ggplot(aes(x = recall, y = precision, group = model), data = results_df_pr) +
geom_line(aes(color = model), size = 1) + scale_color_manual(values = custom_col) +
geom_abline(intercept = sum(imbal_test$Class == "Class2")/nrow(imbal_test), slope = 0, color = "gray", size = 1) +
theme_bw()
auprcSummary <- function(data, lev = NULL, model = NULL){
index_class2 <- data$obs == "Class2"
index_class1 <- data$obs == "Class1"
the_curve <- pr.curve(data$Class2[index_class2], data$Class2[index_class1], curve = FALSE)
out <- the_curve$auc.integral
names(out) <- "AUPRC"
out}
# Re-initialize control function to remove smote and
# include our new summary function
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 5,
summaryFunction = auprcSummary, classProbs = TRUE,
seeds = orig_fit$control$seeds)
orig_pr <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE,
metric = "AUPRC", trControl = ctrl)
# Get results for auprc on the test set
orig_fit_test <- orig_fit %>% calc_auprc(data = imbal_test) %>% (function(the_mod) the_mod$auc.integral)
orig_pr_test <- orig_pr %>% calc_auprc(data = imbal_test) %>% (function(the_mod) the_mod$auc.integral)
# The test errors are the same
identical(orig_fit_test, orig_pr_test)
# The test errors are the same
identical(orig_fit_test, orig_pr_test)
# Because both chose the same hyperparameter combination
# Should be true!
identical(orig_fit$bestTune, orig_pr$bestTune)
if(!require(easypackages)){install.packages("easypackages")}
library(easypackages)
packages("plyr", "dplyr", "xda", "ggplot2", "readr", "gridExtra", "caret", "PRROC", prompt = FALSE)
library(DMwR) # for smote implementation
library(purrr) # for functional programming (map)
library(pROC) # for AUC calculations
set.seed(2969)
imbal_train <- twoClassSim(5000, intercept = -25, linearVars = 20, noiseVars = 10)
imbal_test  <- twoClassSim(5000, intercept = -25, linearVars = 20, noiseVars = 10)
prop.table(table(imbal_train$Class))
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 5, summaryFunction = twoClassSummary, classProbs = TRUE)
# Build a standard classifier using a gradient boosted machine
orig_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build custom AUC function to extract AUC from the caret model object
test_roc <- function(model, data) {
roc(data$Class, predict(model, data, type = "prob")[, "Class2"])}
orig_fit %>% test_roc(data = imbal_test) %>% auc()
# Create model weights (they sum to one)
model_weights <- ifelse(imbal_train$Class == "Class1",
(1/table(imbal_train$Class)[1]) * 0.5,
(1/table(imbal_train$Class)[2]) * 0.5)
# Use the same seed to ensure same cross-validation splits
ctrl$seeds <- orig_fit$control$seeds
# Build weighted model
weighted_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, weights = model_weights,
metric = "ROC", trControl = ctrl)
# Build down-sampled model
ctrl$sampling <- "down"
down_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build up-sampled model
ctrl$sampling <- "up"
up_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
# Build smote model
ctrl$sampling <- "smote"
smote_fit <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE, metric = "ROC", trControl = ctrl)
model_list <- list(original = orig_fit, weighted = weighted_fit, down = down_fit, up = up_fit, SMOTE = smote_fit)
model_list_roc <- model_list %>% map(test_roc, data = imbal_test)
model_list_roc %>% map(auc)
results_list_roc <- list(NA)
num_mod <- 1
for(the_roc in model_list_roc){
results_list_roc[[num_mod]] <-
data_frame(tpr = the_roc$sensitivities,
fpr = 1 - the_roc$specificities,
model = names(model_list)[num_mod])
num_mod <- num_mod + 1
}
results_df_roc <- bind_rows(results_list_roc)
# Plot ROC curve for all 5 models
custom_col <- c("#000000", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
ggplot(aes(x = fpr,  y = tpr, group = model), data = results_df_roc) + geom_line(aes(color = model), size = 1) +
scale_color_manual(values = custom_col) + geom_abline(intercept = 0, slope = 1, color = "gray", size = 1) +
theme_bw(base_size = 18)
calc_auprc <- function(model, data){
index_class2 <- data$Class == "Class2"
index_class1 <- data$Class == "Class1"
predictions <- predict(model, data, type = "prob")
pr.curve(predictions$Class2[index_class2], predictions$Class2[index_class1], curve = TRUE)##pr.curve is in PRROC
}
# Get results for all 5 models
model_list_pr <- model_list %>% map(calc_auprc, data = imbal_test)
model_list_pr %>% map(function(the_mod) the_mod$auc.integral)
# Plot the AUPRC curve for all 5 models
results_list_pr <- list(NA)
num_mod <- 1
for(the_pr in model_list_pr){
results_list_pr[[num_mod]] <- data_frame(recall = the_pr$curve[, 1],
precision = the_pr$curve[, 2],
model = names(model_list_pr)[num_mod])
num_mod <- num_mod + 1
}
results_df_pr <- bind_rows(results_list_pr)
custom_col <- c("#000000", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
ggplot(aes(x = recall, y = precision, group = model), data = results_df_pr) +
geom_line(aes(color = model), size = 1) + scale_color_manual(values = custom_col) +
geom_abline(intercept = sum(imbal_test$Class == "Class2")/nrow(imbal_test), slope = 0, color = "gray", size = 1) +
theme_bw()
set.seed(5627)
auprcSummary <- function(data, lev = NULL, model = NULL){
index_class2 <- data$obs == "Class2"
index_class1 <- data$obs == "Class1"
the_curve <- pr.curve(data$Class2[index_class2], data$Class2[index_class1], curve = FALSE)
out <- the_curve$auc.integral
names(out) <- "AUPRC"
out}
# Re-initialize control function to remove smote and
# include our new summary function
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 5,
summaryFunction = auprcSummary, classProbs = TRUE,
seeds = orig_fit$control$seeds)
orig_pr <- train(Class ~ ., data = imbal_train, method = "gbm", verbose = FALSE,
metric = "AUPRC", trControl = ctrl)
# Get results for auprc on the test set
orig_fit_test <- orig_fit %>% calc_auprc(data = imbal_test) %>% (function(the_mod) the_mod$auc.integral)
orig_pr_test <- orig_pr %>% calc_auprc(data = imbal_test) %>% (function(the_mod) the_mod$auc.integral)
# The test errors are the same - should be TRUE
identical(orig_fit_test, orig_pr_test)
# The test errors are the same - should be TRUE
identical(orig_fit_test, orig_pr_test)
# Because both chose the same hyperparameter combination
# Should be true!
identical(orig_fit$bestTune, orig_pr$bestTune)
getwd()
setwd("~/GitHub/MachineLearning")
dTrain = read.table("./data/isolet1+2+3+4.data.gz", header = FALSE, sep = ',',
stringsAsFactors = FALSE, blank.lines.skip = TRUE)
dTrain$isTest <- FALSE
dTest = read.table("./data/isolet5.data.gz", header = FALSE, sep = ',',
stringsAsFactors = FALSE, blank.lines.skip = TRUE)
dTest$isTest <- TRUE
d <- rbind(dTrain, dTest)
rm(list=c('dTest','dTrain'))
d$V618 <- letters[d$V618]
vars <- colnames(d)[1:617]
yColumn <- 'isN'
d[, yColumn] <- d[,'V618']=='n'
# true prevalence of N
mean(d$isN)
